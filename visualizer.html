<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Visualizer – Track 1 (stable core, 11→21→22)</title>
<style>
  :root{
    --ui-bg: rgba(255,255,255,.88);
    --ui-fg: #3e3e3e;
    --play-oval: rgba(140, 195, 120, .38);
    --font: 400 12px/22px Clarkson, "Proxima Nova", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  }
  html,body{margin:0;height:100%;background:#fff;color:var(--ui-fg);font:var(--font)}
  #vizwrap{position:relative;width:100%;height:100vh;background:#000;overflow:hidden}
  #viz{position:absolute;inset:0;display:block;width:100%;height:100%}

  /* Hover-only controls (no JS-triggered flashes) */
  .ui{
    position:absolute;left:0;right:0;bottom:0;display:flex;align-items:center;gap:.75rem;
    padding:.6rem .8rem;background:var(--ui-bg);color:var(--ui-fg);font:var(--font);
    border-top-left-radius:10px;border-top-right-radius:10px;opacity:0;transform:translateY(8px);
    transition:opacity .25s ease, transform .25s ease;pointer-events:none;
  }
  #vizwrap:hover .ui{opacity:1;transform:none;pointer-events:auto}

  .starter{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,rgba(0,0,0,.30),rgba(0,0,0,.45))
  }
  .play-oval{
    all:unset;cursor:pointer;display:flex;align-items:center;justify-content:center;
    width:112px;height:72px;border-radius:9999px;background:var(--play-oval);
    box-shadow:0 6px 22px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.18)
  }
  .play-oval svg{width:24px;height:24px;fill:#fff}

  .btn{
    all:unset;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;
    width:36px;height:36px;border-radius:9999px;background:rgba(0,0,0,.06);color:var(--ui-fg)
  }
  .btn:hover{background:rgba(0,0,0,.12)}
  .pill{all:unset;cursor:pointer;background:rgba(0,0,0,.06);padding:.35rem .6rem;border-radius:999px}
  .pill:hover{background:rgba(0,0,0,.12)}
  .label{opacity:.85;min-width:52px;text-align:right}
  .grow{flex:1}
  .spacer{width:8px}
  input[type="range"]{
    -webkit-appearance:none;appearance:none;height:4px;width:240px;background:rgba(0,0,0,.18);border-radius:9999px;outline:none
  }
  input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;appearance:none;width:14px;height:14px;border-radius:50%;background:#3e3e3e;box-shadow:0 0 0 2px rgba(255,255,255,.8)
  }
</style>
</head>
<body>
  <div id="vizwrap" aria-label="Audio visualizer">
    <canvas id="viz"></canvas>

    <div class="ui" role="group" aria-label="Player controls">
      <button id="play" class="btn" aria-label="Play/Pause">▶</button>
      <span id="time" class="label">0:00</span>
      <input id="seek" type="range" min="0" max="1" step="0.001" value="0" class="grow" aria-label="Seek"/>
      <span id="dur" class="label">0:00</span>
      <div class="spacer"></div>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9" style="width:110px" aria-label="Volume"/>
      <div class="spacer"></div>
      <button id="next" class="pill" aria-label="Next preset">Next</button>
    </div>

    <div id="starter" class="starter" role="dialog" aria-label="Click to start">
      <!-- Inline onclick = most reliable first-gesture path -->
      <button id="startBtn" class="play-oval" aria-label="Play"
              onclick="window._vizStart && window._vizStart()">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"/></svg>
      </button>
    </div>

    <!-- playsinline added for iOS/Safari -->
    <audio id="player" preload="auto" playsinline crossorigin="anonymous">
      <source src="track.mp3" type="audio/mpeg">
      <!-- <source src="track.wav" type="audio/wav"> -->
    </audio>
  </div>

  <!-- Load libs with fallback (unpkg → jsDelivr) -->
  <script>
  function loadScriptPair(primary, fallback){
    return new Promise((resolve,reject)=>{
      const s=document.createElement('script'); s.src=primary; s.async=false;
      s.onload=resolve;
      s.onerror=()=>{ const f=document.createElement('script'); f.src=fallback; f.async=false;
        f.onload=resolve; f.onerror=()=>reject(new Error('CDN fail '+primary)); document.head.appendChild(f); };
      document.head.appendChild(s);
    });
  }
  (async function libs(){
    const u='https://unpkg.com/', j='https://cdn.jsdelivr.net/npm/';
    try{
      await loadScriptPair(u+'butterchurn@2.6.7/lib/butterchurn.min.js',              j+'butterchurn@2.6.7/lib/butterchurn.min.js');
      await loadScriptPair(u+'butterchurn@2.6.7/lib/butterchurnExtraImages.min.js',   j+'butterchurn@2.6.7/lib/butterchurnExtraImages.min.js');
      await loadScriptPair(u+'butterchurn-presets@2.4.7/lib/butterchurnPresets.min.js', j+'butterchurn-presets@2.4.7/lib/butterchurnPresets.min.js');
      window._libsReady = true;
    }catch(e){
      console.warn('Preset libraries failed to load', e);
      window._libsReady = false;
    }
  })();
  </script>

  <script>
  // ===== helpers =====
  function getBC(){
    const bc = window.butterchurn;
    if(!bc) return null;
    return (typeof bc.createVisualizer === 'function') ? bc :
           (bc.default && typeof bc.default.createVisualizer === 'function') ? bc.default : null;
  }
  function webglOK(){ const c=document.createElement('canvas'); return !!(c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl')); }
  const pad = s => (s<10?'0':'')+s;
  const fmt = t => { if(!isFinite(t)) return '0:00'; const m=(t/60)|0, s=(t%60)|0; return m+':'+pad(s); };
  const log = (...a)=>console.log('[viz1]', ...a);

  // ===== DOM refs =====
  const wrap   = document.getElementById('vizwrap');
  const canvas = document.getElementById('viz');
  const starter= document.getElementById('starter');
  const audio  = document.getElementById('player');
  const btnPlay= document.getElementById('play');
  const btnNext= document.getElementById('next');
  const rSeek  = document.getElementById('seek');
  const rVol   = document.getElementById('vol');
  const tTime  = document.getElementById('time');
  const tDur   = document.getElementById('dur');

  // ===== state =====
  let ctx, src, viz, PRESET_DICT, PRESET_NAMES;
  let keys = [], index = 0, timer = null, started=false;

  function size(){
    const r = wrap.getBoundingClientRect();
    canvas.width = r.width; canvas.height = r.height;
    if (viz) viz.setRendererSize(r.width, r.height);
  }

  // Build order: #11, #21, #22 + next 8 names from the list, skipping dups
  function buildSequence(){
    const names = PRESET_NAMES;
    const by1 = n => names[n-1];                   // convert to zero-based
    const first = [by1(11), by1(21), by1(22)].filter(Boolean);
    const extras = names.filter(n => !first.includes(n)).slice(0, 8);
    const seq = first.concat(extras);
    log('Preset count:', names.length, '| start picks:', first, '| extra picks:', extras.length);
    return seq.length ? seq : names;
  }

  // No UI flash here
  function loadByName(name, blend=1.4){
    const p = PRESET_DICT[name];
    if (!p) { log('Missing preset:', name); return; }
    viz.loadPreset(p, blend);
    log('Loaded:', name);
  }
  function loadByIndex(i, blend){
    index = (i + keys.length) % keys.length;
    loadByName(keys[index], blend);
  }

  // Timing: 140 BPM → 64 bars
  const BPM = 140;
  const MS_PER_BAR = (60000 / BPM) * 4;
  function reschedule(){
    if (timer) clearInterval(timer);
    const interval = Math.round(MS_PER_BAR * 64);
    timer = setInterval(()=> loadByIndex(index+1, 1.6), interval);
    log('Auto-change every', interval, 'ms');
  }

  function buildVizInput(c, mediaSource){
    mediaSource.connect(c.destination);            // speakers (clean)
    const gain = c.createGain(); gain.gain.value = +rVol.value;
    mediaSource.connect(gain);                     // visuals branch with sensitivity
    return gain;
  }

  async function bootCore(){
    if (!webglOK()) { alert('WebGL not available. Enable hardware acceleration.'); return false; }
    // wait (up to ~8s) for libs
    await new Promise(res=>{
      let t=0; const h=setInterval(()=>{ if (window._libsReady){ clearInterval(h); res(); } if (++t>80){ clearInterval(h); res(); } }, 100);
    });
    const BC = getBC();
    if (!BC || !window.butterchurnPresets){ alert('Preset libraries failed to load.'); return false; }

    const LIB = (window.butterchurnPresets.default || window.butterchurnPresets);
    PRESET_DICT = LIB.getPresets();
    PRESET_NAMES = Object.keys(PRESET_DICT);
    log('Core presets available:', PRESET_NAMES.length);

    ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    src = ctx.createMediaElementSource(audio);

    const input = buildVizInput(ctx, src);
    viz = (window.butterchurn.createVisualizer ? window.butterchurn : window.butterchurn.default)
            .createVisualizer(ctx, canvas, { width: canvas.clientWidth, height: canvas.clientHeight, pixelRatio: 1 });
    viz.connectAudio(input);

    keys = buildSequence();
    // don't load presets or start render loop until audio is playing
    size(); window.addEventListener('resize', size, {passive:true});
    return true;
  }

  // ===== start + controls (robust, no popups) =====
  function showErr(e){ console.warn('Start/play warning:', e && e.message ? e.message : e); }

  async function startPlayback(){
    try{
      if (!ctx){
        const ok = await bootCore();
        if (!ok) return;
      }
      if (ctx.state === 'suspended') await ctx.resume();
      if (audio.paused){ try{ await audio.play(); }catch(e){ showErr(e); } }

      if (!started){
        started=true;
        // start visuals only after audio begins
        loadByIndex(0, 0);
        (function loop(){ if (viz) viz.render(); requestAnimationFrame(loop); })();
        reschedule();

        // progress + restart logic
        let lastT=0;
        audio.addEventListener('timeupdate', ()=>{
          const t = audio.currentTime||0;
          if (audio.duration){
            rSeek.value = t / audio.duration;
            tTime.textContent = fmt(t);
            tDur.textContent  = fmt(audio.duration);
          }
          if (t<1 && lastT>5){ index=0; keys=buildSequence(); loadByIndex(0,0); reschedule(); }
          lastT = t;
        }, {passive:true});
      }

      document.getElementById('starter').style.display='none';
      btnPlay.textContent='⏸';
    }catch(e){ showErr(e); }
  }

  // Global starter so inline onclick can reach it
  window._vizStart = async function(){ return startPlayback(); };

  // Start on ANY pointer (helps inside iframes/Safari)
  document.addEventListener('pointerdown', ()=>{ 
    if (!ctx || (audio && audio.paused)) window._vizStart(); 
  }, { once: true, passive: true });

  // Also bind to canvas specifically (some builders overlay the first click)
  canvas.addEventListener('pointerdown', ()=>{ 
    if (!ctx || (audio && audio.paused)) window._vizStart(); 
  }, { passive: true });

  // Extra listeners
  document.getElementById('startBtn').addEventListener('click', startPlayback);
  document.getElementById('starter').addEventListener('click', (e)=>{ if (e.target.id==='starter') startPlayback(); });
  canvas.addEventListener('click', startPlayback);
  document.addEventListener('keydown', (e)=>{ if (e.code==='Space'||e.key==='Enter') startPlayback(); });

  btnPlay.addEventListener('click', async ()=>{
    try{
      if (!ctx) await startPlayback();
      if (audio.paused){ try{ await audio.play(); }catch(e){} btnPlay.textContent='⏸'; }
      else { audio.pause(); btnPlay.textContent='▶'; }
    }catch(e){ showErr(e); }
  });

  btnNext.addEventListener('click', ()=> loadByIndex(index+1, 1.2));
  rSeek.addEventListener('input', e=>{ if (audio.duration) audio.currentTime = e.target.value * audio.duration; });
  rVol.addEventListener('input', e=>{ audio.volume = +e.target.value; });
  </script>
</body>
</html>
